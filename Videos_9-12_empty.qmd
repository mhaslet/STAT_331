---
title: "Videos 9 - 12"
format:
  html:
    toc: true
    toc-depth: 5
    toc-expand: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE)
```

## **Video 9) Iterations – 1: Looping Structures**

Looping structures are used to repeat a block of code multiple times.

-   There is also a `do` loop but we won't talk about it

### `for` loop:

Repeats code for each item in a sequence. This is useful when you have a known number of iterations.

```{r}
# Get the mean of a few columns in mtcars
cols_to_summarize <- c("mpg", "hp", "wt", "qsec")

for (col in cols_to_summarize) {
# Calculate the mean of the current column
current_mean <- mean(mtcars[[col]])
# Print the result
print(paste("Mean of", col, ":", round(current_mean, 2)))
}
```

**Question 1**

Write a `for` loop that iterates through the sequence of numbers from 1 to 5, printing a descriptive message for each iteration.

```{r}
# This loop will run for each number in the sequence from 1 to 5
for (i in 1:5) {
# The 'i' variable will hold the current number in the sequence (1, then 2, etc.)
print(paste("This is iteration number:", i))
}
```

-   `1:5` is a vector from 1 to 5

-   Could also use `seq(1,5)`

::: {style="height: 150px; background-color: white;"}
:::

### `while` loop:

Repeats code as long as a specified condition is **TRUE**. This is useful when the number of iterations is not known beforehand.

```{r}
# Print car names until horsepower (hp) exceeds 120
i <- 1
# The loop continues as long as the hp of the car at row 'i' is less than 120
while (mtcars$hp[i] < 120) {
print(rownames(mtcars)[i])
i <- i + 1
}
```

-   Once `hp > 120`, the while loop stops executing code

-   While `hp < 120`, the code continues looping

**Question 2**

Using a `while` loop, write a script that counts from 1 to 5, printing a message like 'The current count is: \[number\]' at each step.

```{r}

# 1. Initialize a counter variable before the loop starts
counter <- 1

# 2. Set the condition. The loop will run as long as 'counter' is less than or equal to 5.
while (counter <= 5) {

# 3. This is the code that gets executed in each iteration
print(paste("The current count is:", counter))

# 4. IMPORTANT: Increment the counter. Without this, the loop would run forever.
counter <- counter + 1
}
```

-   Start `counter` at 1, check if it's less than or equal to 5, if true then print, then increment `counter` by 1

::: {style="height: 150px; background-color: white;"}
:::

### `repeat` loop:

Repeats code indefinitely until a `break` statement is executed.

-   Repeating the task in { } until the break statement can be executed
-   Keeps iterating until the if statement condition is met

```{r}
# Find the first car with 8 cylinders
i <- 1
repeat {
# Check if the current car has 8 cylinders
if (mtcars$cyl[i] == 8) {
print(paste("First 8-cylinder car found:", rownames(mtcars)[i]))
break # Exit the loop
}
i <- i + 1
}
```

::: {style="height: 300px; background-color: white;"}
:::

## **Video 10) Control Structures: Conditional Logic**

Control structures allow you to execute different blocks of code based on specified conditions.

### `if`, `else if`, `else`:

Executes code based on a series of logical checks.

```{r}
# Check the fuel efficiency of the 'Mazda RX4'
mpg <- mtcars["Mazda RX4", "mpg"]

if (mpg > 25) {
print("High fuel efficiency")
} else if (mpg >= 18) {
print("Average fuel efficiency")
} else {
print("Low fuel efficiency")
}
```

-   `mtcars["Mazda RX4", "mpg"]` allows us to get the row `Mazda RX4` and the column `mpg`

**Question 1**

Write a script that first creates a variable named `score` and assigns it the value `85`. Then, using an `if`, `else if`, and `else` structure, print the corresponding letter grade: "Grade: A" for scores 90 and above, "Grade: B" for scores 80 and above, and "Grade: C or below" for all other scores.

```{r}
# Create a variable for a student's score
score <- 85

if (score >= 90) {
print("Grade: A")
} else if (score >= 80) {
print("Grade: B")
} else {
print("Grade: C or below")
}
```

`ifelse()`

-   Does an if/else statement vector-wise

-   Beneficial when working with a data frame

```{r}
ifelse(mtcars$mpg > 20, "Good Eff.", "Bad Eff.")
```

-   Could also use `dplyr::if_else` which is more efficient

::: {style="height: 150px; background-color: white;"}
:::

### `switch()`:

Selects a block of code to execute based on an exact match of a value. It's a cleaner alternative to a long `if/else if` chain.

-   Based off the cylinder of the Valian car, the function will return a different output

```{r}
# Describe a car based on its number of cylinders
cylinders <- mtcars["Valiant", "cyl"]

switch(as.character(cylinders),
"4" = "A small, efficient engine.",
"6" = "A balanced, mid-size engine.",
"8" = "A large, powerful engine.",
"Unknown engine size."
)
```

**Question 2**

Write a script that first creates a variable named `day` and assigns it the value "Wednesday". Then, use the `switch()` function to print a specific message if the day is "Monday" or "Friday", and a default message for any other day of the week.

```{r}
# Create a variable for a day of the week
day <- "Wednesday"

switch(day,
"Monday" = "Beginning of the week",
"Friday" = "End of the week",
"Just another day" # Default case
)
```

::: {style="height: 300px; background-color: white;"}
:::

## **Video 11) Quarto Files and Functions: Defining and Using**

Functions are reusable blocks of code that perform a specific task.

### Quarto Files

-   File type that allows you to program in R and Python and also in Markdown

-   Can create documents, websites, etc.

-   See: `learning.qmd`

### Basic function structure:

Defines a simple function that takes inputs (arguments) and provides an output (`return` value).

```{r}
# Create a function to convert weight from (lbs/1000) to kilograms
convert_wt_to_kg <- function(weight_in_tons) {
kg <- weight_in_tons * 1000 * 0.453592
return(kg)
}

# Use the function on the 'Datsun 710'
datsun_kg <- convert_wt_to_kg(mtcars["Datsun 710", "wt"])
print(datsun_kg)
```

-   If you don't explicitly say `return()` then the last item executed will be returned

-   `function()` is the function itself, `weight_in_tons` is the input that the user provides, return element is then specified

**Question 1**

Write a custom R function named `add_numbers` that accepts two arguments, `x` and `y`. Inside the function, calculate their sum and use the `return()` statement to output the result. After defining the function, test it by calling it with the numbers `5` and `10`, and then print the final result to the console.

-   Two inputs: x and y

```{r}
# Create a function that adds two numbers
add_numbers <- function(x, y) {
result <- x + y
return(result)
}

# Use the function
sum_result <- add_numbers(5, 10)
print(sum_result)
```

::: {style="height: 150px; background-color: white;"}
:::

### Function with default arguments:

Assigns a default value to an argument, which is used if no value is provided by the user.

-   If the user does not provide a value for the variable we will specify a value for the variable

```{r}
# Function to get the top 'n' cars based on a column
get_top_cars <- function(n = 3, column = "hp") {
# Order the data frame by the specified column in descending order
sorted_cars <- mtcars[order(mtcars[[column]], decreasing = TRUE), ]
# Return the top 'n' rows
return(head(sorted_cars, n))
}

# Call with default arguments (top 3 by horsepower)
get_top_cars()

# Call with top 7 horsepower
get_top_cars(n = 7)

# Call with top 3 mpg
get_top_cars(column = "mpg")
```

**Question 2**

Write a custom R function named `greet` that takes a single argument, `name`. Set a default value for `name` to be "Guest". The function should combine the string "Hello, " with the provided name and an exclamation mark. After defining the function, test it twice: first by calling it with no arguments to see the default behavior, and a second time by providing the name "Ana".

```{r}
# A function to create a greeting message
greet <- function(name = "Guest") {
paste0("Hello, ", name, "!")
}

# Call with the default argument
greet()
# Call with a provided argument
greet(name = "Molly")
```

::: {style="height: 150px; background-color: white;"}
:::

### Multiple outputs (as a list):

A function can return multiple values by packaging them into a list.

-   Providing a list back

-   List can be used within a function as an output which can be then turned into a data frame

    -   critical in having multiple data frames, wanting to condense them

```{r}
# Function to get key stats for a column
get_stats <- function(column_vector) {
list(
average = mean(column_vector),
median_val = median(column_vector),
std_dev = sd(column_vector)
)
}

# Get stats for the mpg column
mpg_stats <- get_stats(mtcars$mpg)
class(mpg_stats)
print(mpg_stats)
```

-   Applying a vector to the function, then it finds its mean, median, and standard deviation and stores it as a `list()`

    -   The return element is thus a list

-   Didn't necessarily have to name the variables within the list, it would just give them index names `[[*]]`

    -   Better to name them for easier access instead of having to index through the list for the value you want

**Question 3**

Write a custom R function named `get_vector_stats` that accepts a single argument, a numeric vector. Inside the function, calculate both the `mean` and the `sum` of the vector and store them as a named `list`. The function should then `return` this list. After defining the function, test it by calling it with the vector `c(10, 20, 30)` and printing only the `average` from the resulting list.

```{r}
# Function to get key stats for a numeric vector
get_vector_stats <- function(num_vec) {
stat_list <- list(
average = mean(num_vec, na.rm = TRUE),
total_sum = sum(num_vec, na.rm = TRUE)
)
return(stat_list)
}

# Get stats for a simple vector
stats <- get_vector_stats(c(10, 20, 30, NA))
print(stats)

```

-   If the input vector contains `NA` values, all outputs will be `NA`

    -   To fix: add `na.rm = TRUE` in the arguments of `mean()` and `sum()`

::: {style="height: 300px; background-color: white;"}
:::

## **Video 12) Iterations – 2: Functional Programming with `{purrr}`**

In this video, we'll focus on functional programming, a powerful alternative to writing loops. We will use the **`{purrr}`** package, which provides a consistent set of tools for iterating over lists and vectors. The main idea is to apply a function to each element of an object. This often results in code that is more concise and easier to read than a `for` loop.

-   A lot of perks that allow you to clean data in more efficient ways and not using for loops

```{r}
# Load the purrr package
library(purrr)
```

::: {style="height: 100px; background-color: white;"}
:::

### `map()`: Apply a function to each element

The `map()` function is the foundation of `{purrr}`. It takes a vector or list as input, applies a function to each of its elements, and **always returns a list**.

-   `map(vector, function)` with a given vector and a defined function that will be applied to each element in the vector

-   Ideally, want to store it as a vector for use in a data frame

```{r}
# Let's create a simple function to square a number
square_a_number <- function(x) {
return(x^2)
}

# Now, use map() to apply this function to each number in our vector
numbers_to_square <- 2:6

# map() will return a list of the results
squared_list <- map(numbers_to_square, square_a_number)

print(squared_list)
```

### Type-Specific Maps: `map_dbl()` and `map_chr()`

Often, you don't want a list back; you want a simple vector. `purrr` provides variants like `map_dbl()` (returns a numeric/double vector) and `map_chr()` (returns a character vector) for this purpose.

```{r}
# Using map_dbl() returns a clean numeric vector instead of a list
squared_vector <- map_dbl(numbers_to_square, square_a_number)

print(squared_vector)
```

```{r}
# Let's create a function that returns text
create_greeting <- function(name) {
paste("Hello,", name, sep = " ")
}

student_names <- c("Jameare", "Jimmy", "John")

# Use map_chr() to get a character vector of greetings
greetings <- map_chr(student_names, create_greeting)

print(greetings)
```

::: {style="height: 150px; background-color: white;"}
:::

### `map2()`: Iterate over two vectors at once

The `map2()` function lets you iterate over two vectors in parallel. The function you provide must accept two arguments.

-   The first two arguments of `map2()` are the two parallel vectors, the final argument in `map2()` is the function

-   Say you have `p` vectors you want to apply a function to at the same time, then you'd need to use `pmap()`

```{r}
# Let's create a simple function to add two numbers
add_two_numbers <- function(x, y) {
return(x + y)
}

# Create two vectors of the same length
first_numbers <- seq(3,10,3)
second_numbers <- 10:12

# Use map2_dbl() to apply the function to corresponding elements
# The first element of 'first_numbers' is added to the first of 'second_numbers', and so on.
sums <- map2_dbl(first_numbers, second_numbers, add_two_numbers)

print(sums)
```

::: {style="height: 150px; background-color: white;"}
:::

### `walk()`: For functions with side effects

Sometimes you want to call a function not for what it *returns*, but for what it *does*—like printing a message or saving a file. This is called a "side effect." `walk()` works just like `map()`, but it doesn't return anything. It's used exclusively for triggering side effects.

-   Utilizing a data frame

#### Method 1

```{r}
# Let's create a function that just prints a message
print_a_summary <- function(name, grade) {
print(paste(name, "received a grade of", grade))
}

# Create our data
student_data <- data.frame(
name = c("Ana", "Ben", "Charlie"),
grade = c(92, 85, 88)
)

# Use walk2() to iterate over two columns and print a summary for each student
# Note that nothing is saved to an object. The output is printed directly to the console.
walk2(student_data$name, student_data$grade, print_a_summary)
```

#### Method 2

```{r}
# Pipe the data frame into pwalk()
student_data %>%
pwalk(print_a_summary)
```

-   To use `pwalk()`, the name and grade variables created in the data frame have to be in the correct order for it to work